df['cleaned_value'] = df.apply(
    lambda row: clean(row['value']) if row['level'] == 'naics2' else row['value'],
    axis=1
)



import pandas as pd
from concurrent.futures import ThreadPoolExecutor
from itertools import product

# üîß Placeholder for your actual data fetch function
def DOM(fips, year):
    # Example placeholder ‚Äî replace with real logic
    raise NotImplementedError("You must implement DOM(fips, year) to return a DataFrame.")

# üîç Mismatch computation logic by FIPS
def calculate_naics_mismatches_by_fips(df):
    df = df.copy()

    df['naics3'] = df['naics3'].astype(str).str.zfill(3)
    df['naics4'] = df['naics4'].astype(str).str.zfill(4)
    df['naics5'] = df['naics5'].astype(str).str.zfill(5)
    df['naics6'] = df['naics6'].astype(str).str.zfill(6)

    def parse_naics2_range(val):
        try:
            if '-' in val:
                start, end = map(int, val.split('-'))
                return {str(i).zfill(2) for i in range(start, end + 1)}
            else:
                return {val.zfill(2)}
        except:
            return set()

    df['naics2_set'] = df['naics2'].astype(str).apply(parse_naics2_range)

    df['mismatch_naics3'] = ~df.apply(lambda x: x['naics3'][:2] in x['naics2_set'], axis=1)
    df['mismatch_naics4'] = ~df.apply(lambda x: x['naics4'][:2] in x['naics2_set'], axis=1)
    df['mismatch_naics5'] = ~df.apply(lambda x: x['naics5'][:2] in x['naics2_set'], axis=1)
    df['mismatch_naics6'] = ~df.apply(lambda x: x['naics6'][:2] in x['naics2_set'], axis=1)

    summary = df.groupby('fips').agg(
        total=('naics2', 'count'),
        naics3_mismatch_pct=('mismatch_naics3', 'mean'),
        naics4_mismatch_pct=('mismatch_naics4', 'mean'),
        naics5_mismatch_pct=('mismatch_naics5', 'mean'),
        naics6_mismatch_pct=('mismatch_naics6', 'mean')
    ).reset_index()

    for col in ['naics3_mismatch_pct', 'naics4_mismatch_pct', 'naics5_mismatch_pct', 'naics6_mismatch_pct']:
        summary[col] = (summary[col] * 100).round(2)

    return summary

# üì¶ Helper function: fetch and tag data for (fips, year)
def fetch_and_process_fips_year(fips, year):
    try:
        df = DOM(fips, year)
        if df is not None and not df.empty:
            df = df.copy()
            df['fips'] = fips
            return df
        return None
    except Exception as e:
        print(f"Error fetching data for FIPS {fips}, Year {year}: {e}")
        return None

# üöÄ Main function: multithreaded collection and mismatch summary by FIPS
def calculate_mismatches_by_fips_multithread(FIPS):
    years = range(2020, 2025)
    tasks = []

    with ThreadPoolExecutor() as executor:
        for fips, year in product(FIPS, years):
            tasks.append(executor.submit(fetch_and_process_fips_year, fips, year))

        results = [task.result() for task in tasks if task.result() is not None]

    if results:
        combined_df = pd.concat(results, ignore_index=True)
        return calculate_naics_mismatches_by_fips(combined_df)
    else:
        return pd.DataFrame()
