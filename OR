import pandas as pd
import us
from concurrent.futures import ThreadPoolExecutor, as_completed

def count_ui_naics_multi_by_level():
    """
    For each yr_qtr, state, and NAICS level (2 to 6), count:
    - UIs with only one unique NAICS (single-establishment)
    - UIs with more than one NAICS (multi-establishment)

    Returns a DataFrame:
    ['yr_qtr', 'state', 'naics_level', 'single_ui_count', 'multi_ui_count']
    """
    def process_dom(year, fips):
        try:
            df = DOM2(year, fips)
            df = df[['yr_qtr', 'state', 'UI', 'naics2', 'naics3', 'naics4', 'naics5', 'naics6']].dropna()
            df = df.astype({'naics2': str, 'naics3': str, 'naics4': str, 'naics5': str, 'naics6': str})

            summaries = []

            for level in ['naics2', 'naics3', 'naics4', 'naics5', 'naics6']:
                grouped = df.groupby(['yr_qtr', 'state', 'UI'])[level].nunique().reset_index()
                grouped['ui_type'] = grouped[level].apply(lambda x: 'single' if x == 1 else 'multi')

                summary = (
                    grouped.groupby(['yr_qtr', 'state', 'ui_type'])['UI']
                    .nunique()
                    .unstack(fill_value=0)
                    .reset_index()
                    .rename(columns={'single': 'single_ui_count', 'multi': 'multi_ui_count'})
                )

                summary['naics_level'] = level
                if 'single_ui_count' not in summary.columns:
                    summary['single_ui_count'] = 0
                if 'multi_ui_count' not in summary.columns:
                    summary['multi_ui_count'] = 0

                summaries.append(summary)

            return pd.concat(summaries, ignore_index=True)

        except Exception as e:
            print(f"Error processing year={year}, fips={fips}: {e}")
            return pd.DataFrame(columns=['yr_qtr', 'state', 'single_ui_count', 'multi_ui_count', 'naics_level'])

    # Build (year, fips) jobs
    year_range = range(2020, 2025)
    fips_list = [state.fips for state in us.states.STATES if state.fips is not None]
    jobs = [(year, fips) for year in year_range for fips in fips_list]

    # Run in parallel
    all_results = []
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(process_dom, year, fips) for year, fips in jobs]
        for future in as_completed(futures):
            result = future.result()
            if not result.empty:
                all_results.append(result)

    # Combine all state-year-level results
    final_df = pd.concat(all_results, ignore_index=True)
    final_df = final_df.groupby(['yr_qtr', 'state', 'naics_level'], as_index=False).sum()

    return final_df
