
import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed

def process_one_combo(fips, year, qtr):
    """Extract and summarize high wages for one fips-year-quarter."""
    
    df = Extract_QTR(fips, year, qtr)  # output includes 'state', not fips
    df["fips_used"] = str(fips)

    # Filter wages > $1M
    df_hi = df[df["WAGE"] > 1_000_000].copy()
    if df_hi.empty:
        return None

    # Summarize by state (string returned by Extract_QTR)
    summary = df_hi.groupby("state").agg(
        high_wage_count=("UI", "nunique"),
        max_wage=("WAGE", "max"),
        min_wage=("WAGE", "min"),
        total_high_wages=("WAGE", "sum")
    ).reset_index()

    summary["fips_used"] = str(fips)
    summary["year"] = year
    summary["quarter"] = qtr

    return summary


def high_wage_summary_mt(fips_list, start_year=2020, end_year=2025, max_workers=24):
    """Multithreaded batch processing with no exception handling."""
    
    tasks = []
    with ThreadPoolExecutor(max_workers=max_workers) as executor:

        for fips in fips_list:
            for year in range(start_year, end_year + 1):

                quarters = [1] if year == 2025 else [1, 2, 3, 4]

                for qtr in quarters:
                    tasks.append(
                        executor.submit(process_one_combo, fips, year, qtr)
                    )

        results = []
        for t in as_completed(tasks):
            r = t.result()       # no try/except â€” errors propagate
            if r is not None:
                results.append(r)

    return (
        pd.concat(results, ignore_index=True)
        if results
        else pd.DataFrame()
    )
