import re
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

def _parse_yr_qtr_order(s):
    m = re.match(r"(\d{4})Q([1-4])", str(s))
    return (int(m.group(1)), int(m.group(2))) if m else (0, 0)

def plot_wage_viz(master: pd.DataFrame, view="bubble", naics2=None, value=None,
                  annotate=True, blip_delta=0.05, save_html=None):
    df = master.copy()

    if view == "bubble":
        # RQ: Are wage increases broad-based or driven by a few high earners/bonuses?
        df["avg_wage"] = df["all_total_wages"] / df["all_id_count"].replace(0, pd.NA)
        fig = px.scatter(
            df,
            x="avg_wage",
            y="all_id_count",
            size="all_total_wages",
            color="NAICS2",
            animation_frame="yr_qtr",
            hover_data=["NAICS2","yr_qtr","all_total_wages","all_id_count"],
            size_max=60,
            labels={"avg_wage":"Average wage","all_id_count":"ID count","all_total_wages":"Total wages"},
            title="RQ1 · Broad-based growth vs. lumpy bonuses — Avg Wage (x) vs ID Count (y), size=Total Wages"
        )

    elif view == "stacked_counts":
        # RQ2: How does employee density shift between industries over time?
        fig = px.bar(
            df,
            x="yr_qtr",
            y="all_id_count",
            color="NAICS2",
            barmode="stack",
            labels={"yr_qtr":"Quarter","all_id_count":"ID count"},
            title="RQ2 · Employee density shifts — Stacked ID Counts by NAICS2 over time"
        )

    elif view == "stacked_wages":
        # RQ3: Which industries drive wage growth; are gains concentrated?
        fig = px.bar(
            df,
            x="yr_qtr",
            y="all_total_wages",
            color="NAICS2",
            barmode="stack",
            labels={"yr_qtr":"Quarter","all_total_wages":"Total wages"},
            title="RQ3 · Wage mass concentration — Stacked Total Wages by NAICS2 over time"
        )

    elif view == "heatmap_counts":
        # RQ4: Where are the sharp changes in employee density?
        pivot = df.pivot(index="NAICS2", columns="yr_qtr", values="all_id_count").fillna(0)
        # ensure chronological columns
        cols_sorted = sorted(pivot.columns, key=_parse_yr_qtr_order)
        pivot = pivot[cols_sorted]
        fig = px.imshow(
            pivot,
            labels=dict(x="Quarter", y="NAICS2", color="ID count"),
            aspect="auto",
            title="RQ4 · Sharp changes in density — Heatmap of ID Counts (NAICS2 × Quarter)"
        )

    elif view == "heatmap_wages":
        # RQ5: Are there wage-mass surges suggesting bonuses/payouts?
        pivot = df.pivot(index="NAICS2", columns="yr_qtr", values="all_total_wages").fillna(0)
        cols_sorted = sorted(pivot.columns, key=_parse_yr_qtr_order)
        pivot = pivot[cols_sorted]
        fig = px.imshow(
            pivot,
            labels=dict(x="Quarter", y="NAICS2", color="Total wages"),
            aspect="auto",
            title="RQ5 · Wage-mass surges — Heatmap of Total Wages (NAICS2 × Quarter)"
        )

    elif view == "band_shares":
        # RQ6: Are workers moving between wage bands; do we see “blips”?
        if naics2 is None:
            raise ValueError("For view='band_shares', provide naics2.")
        d = df[df["NAICS2"].astype(str) == str(naics2)].copy()
        if d.empty:
            raise ValueError(f"No rows for NAICS2={naics2}")
        d["__yr__"], d["__q__"] = zip(*d["yr_qtr"].map(_parse_yr_qtr_order))
        d = d.sort_values(["__yr__", "__q__"])
        bin_id_cols = [c for c in d.columns if c.endswith("__id_count")]
        d["__den__"] = d["all_id_count"].replace(0, pd.NA)
        for c in bin_id_cols:
            d[c.replace("__id_count","__id_share")] = d[c] / d["__den__"]
        share_cols = [c for c in d.columns if c.endswith("__id_share")]
        long = d.melt(id_vars=["yr_qtr"], value_vars=share_cols, var_name="band", value_name="share")
        long["band"] = long["band"].str.replace("__id_share","", regex=False)
        # detect “blips”: big QoQ changes per band
        long["__yr__"], long["__q__"] = zip(*long["yr_qtr"].map(_parse_yr_qtr_order))
        long = long.sort_values(["band","__yr__","__q__"])
        long["delta"] = long.groupby("band")["share"].diff()
        fig = px.line(
            long, x="yr_qtr", y="share", color="band",
            labels={"share":"Share of employees","yr_qtr":"Quarter","band":"Wage band"},
            title=f"RQ6 · Wage-band density shifts & blips — NAICS2 {naics2}"
        )
        if annotate:
            spikes = long.loc[long["delta"].abs() >= blip_delta].copy()
            for _, r in spikes.iterrows():
                fig.add_trace(go.Scatter(
                    x=[r["yr_qtr"]], y=[r["share"]],
                    mode="markers+text", text=[f"{r['band']} Δ {r['delta']:+.1%}"],
                    textposition="top center", marker=dict(size=8), showlegend=False
                ))
    else:
        raise ValueError("view must be one of: 'bubble','stacked_counts','stacked_wages','heatmap_counts','heatmap_wages','band_shares'")

    if save_html:
        fig.write_html(save_html, include_plotlyjs="cdn", full_html=True)
    fig.show()
    return fig
# Bubble: RQ1
plot_wage_viz(master, view="bubble")

# Stacked bars: RQ2 and RQ3
plot_wage_viz(master, view="stacked_counts")
plot_wage_viz(master, view="stacked_wages")

# Heatmaps: RQ4 and RQ5
plot_wage_viz(master, view="heatmap_counts")
plot_wage_viz(master, view="heatmap_wages")

# Band shares with automatic “blip” annotations: RQ6
plot_wage_viz(master, view="band_shares", naics2="52", annotate=True, blip_delta=0.05)
