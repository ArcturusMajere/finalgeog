import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed
from queue import Queue

def LOOK2_multithreaded(years, quarters, max_threads=4):
    """
    Run extraction(year, quarter) in parallel over all
    combinations of years Ã— quarters, then concatenate the results.
    
    Returns a single DataFrame of all conflict rows.
    """
    result_queue = Queue()

    def thread_worker(year, quarter):
        try:
            df = extraction(year, quarter)   # your function should return a DataFrame
            if not df.empty:
                # tag rows so we know their origin
                df = df.assign(YR=year, QTR=quarter)
                result_queue.put(df)
        except Exception as e:
            print(f"[{year}-{quarter}] failed: {e}")

    # build all (year, quarter) tasks
    tasks = [(y, q) for y in years for q in quarters]

    # fire off threads
    with ThreadPoolExecutor(max_workers=max_threads) as executor:
        futures = {
            executor.submit(thread_worker, y, q): (y, q)
            for y, q in tasks
        }
        for fut in as_completed(futures):
            y, q = futures[fut]
            try:
                fut.result()
            except Exception as e:
                print(f"[{y}-{q}] unhandled exception: {e}")

    # collect all the DataFrames
    dfs = []
    while not result_queue.empty():
        dfs.append(result_queue.get())

    # return concatenated result (or empty DF if none)
    if not dfs:
        return pd.DataFrame(columns=['ID','WAGE','UI','NAICS2','YR','QTR'])
    return pd.concat(dfs, ignore_index=True)
