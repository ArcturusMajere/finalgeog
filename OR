



@timer
def Extract_QTR(fips, year, quarter, naics=None):
    
    # -------------------------------------------------------------
    # 1) Build optional SQL NAICS filter
    # -------------------------------------------------------------
    naics_sql, naics_param = build_naics_filter_sql(naics)

    query = f"""
        SELECT *
        FROM YQQ
        WHERE state_code = :fips
          AND YR = :year
          AND qtr = :quarter
          {naics_sql}
    """

    params = {
        'fips': fips,
        'year': year,
        'quarter': quarter
    }
    params.update(naics_param)

    # -------------------------------------------------------------
    # 2) Execute query
    # -------------------------------------------------------------
    conn = oracledb.connect(
        user=open('USER.txt').read(),
        password=open('password.txt').read(),
        dsn="XQQQ"
    )

    WR = Fetch_WR_QTR(query, params, conn)

    # -------------------------------------------------------------
    # 3) Fetch DOM and merge like before
    # -------------------------------------------------------------
    D = Fetch_DOM_QTR(year, quarter, fips)
    D['UI'] = D['UI'].str.zfill(10)

    WR1 = WR[WR['WAGE'] != 0]
    WR2 = dupeID(WR1)

    df = pd.merge(WR2, D, how='left', on=['UI', 'RUN'], indicator=True)
    df1 = dupeID(df)

    q2 = df1.shape[0]
    df1['yr_qtr'] = df1['YR'].astype(str) + "-" + df1['QTR'].astype(str)
    df1['state'] = [fips2name(code) for code in df1['fips']]
    df1['sector'] = [lookup_naics2(code) for code in df1['naics2']]

    df_subset = df1.groupby(['yr_qtr', 'state', 'sector']).agg(
        counts=('BLS_ID', 'count'),
        mean_wage=('WAGE', 'mean'),
        median_wage=('WAGE', 'median'),
        percentile75=('WAGE', lambda x: x.quantile(0.75)),
        percentile25=('WAGE', lambda x: x.quantile(0.25))
    ).reset_index()

    print(f"{q2} unique IDs in {fips2name(fips)} @ {year} Q{quarter} (NAICS={naics})")
    return df1, df_subset

Extract_QTR("35", 2024, 2)


def build_naics_filter_sql(naics):
    """
    Returns SQL snippet and parameters for optional NAICS filter.
    """
    if naics is None:
        return "", {}     # no filter
    
    if not naics.isdigit():
        raise ValueError("NAICS filter must be numeric")

    length = len(naics)

    if length == 2:
        return " AND naics2 LIKE :naics", {"naics": naics + "%"}
    elif length == 3:
        return " AND naics3 LIKE :naics", {"naics": naics + "%"}
    elif length == 4:
        return " AND naics4 LIKE :naics", {"naics": naics + "%"}
    elif length in (5, 6):
        return " AND naics6 LIKE :naics", {"naics": naics + "%"}
    else:
        raise ValueError("NAICS must be 2â€“6 digits")
#******************************************************************************

from concurrent.futures import ThreadPoolExecutor, as_completed

def build_task_list_for_state(state_abbr, years, quarters):
    fips = abbr2fips(state_abbr)
    tasks = []
    for yr in years:
        for q in quarters:
            tasks.append((fips, yr, q, state_abbr))
    return tasks

def build_task_list_for_states(state_list, years, quarters):
    tasks = []
    for st in state_list:
        tasks.extend(build_task_list_for_state(st, years, quarters))
    return tasks

def run_extract_multithread(tasks, max_workers=8):
    results_full = []
    results_sub = []
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_map = {
            executor.submit(Extract_QTR, fips, year, qtr): (fips, year, qtr, st)
            for (fips, year, qtr, st) in tasks
        }
        for future in tqdm(as_completed(future_map), total=len(future_map)):
            fips, year, qtr, st = future_map[future]
            try:
                df_full, df_sub = future.result()
            except Exception as e:
                print(f"Error for {st} {year} Q{qtr}: {e}")
                continue
            df_full = df_full.assign(state_abbr=st, year=year, quarter=qtr)
            df_sub = df_sub.assign(state_abbr=st, year=year, quarter=qtr)
            results_full.append(df_full)
            results_sub.append(df_sub)
    all_full = pd.concat(results_full, ignore_index=True) if results_full else pd.DataFrame()
    all_sub = pd.concat(results_sub, ignore_index=True) if results_sub else pd.DataFrame()
    return all_full, all_sub

def extract_state_over_time_multithread(state_abbr, years, quarters, max_workers=4):
    tasks = build_task_list_for_state(state_abbr, years, quarters)
    return run_extract_multithread(tasks, max_workers=max_workers)

def extract_all_states_over_time_multithread(years, quarters, max_workers=8):
    tasks = build_task_list_for_states(states, years, quarters)
    return run_extract_multithread(tasks, max_workers=max_workers)

# examples of use:
# years = [2022, 2023, 2024]
# quarters = [1, 2, 3, 4]
# full_one_state, sub_one_state = extract_state_over_time_multithread("NM", years, quarters, max_workers=4)
# full_all, sub_all = extract_all_states_over_time_multithread(years, quarters, max_workers=16)
