import oracledb
from concurrent.futures import ThreadPoolExecutor,as_completed
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

def cohort_presence_gaps_and_plots(cohortlist,fiplist,start_year,start_qtr,end_year,end_qtr,dsn,user,password,table_name="your_table",workers=6,chunk_size=1000,save_presence_csv=None,save_summary_csv=None,save_per_state_csv=None,save_longest_plot=None,save_distribution_plot=None,show_plots=False):
    def periods(sy,sq,ey,eq):
        out=[];y,q=sy,sq
        while (y<ey) or (y==ey and q<=eq):
            out.append((y,q,f"{y}-{q:02d}"))
            q+=1
            if q==5: q=1; y+=1
        return out
    per=periods(start_year,start_qtr,end_year,end_qtr)
    pool=oracledb.SessionPool(user=user,password=password,dsn=dsn,min=workers,max=workers,increment=0,homogeneous=True,timeout=60,getmode=oracledb.SPOOL_ATTRVAL_WAIT)
    def run_chunk(id_chunk):
        if not id_chunk: return []
        iph=",".join([f":i{k}" for k in range(len(id_chunk))])
        fph=",".join([f":f{k}" for k in range(len(fiplist))])
        params={f"i{k}":v for k,v in enumerate(id_chunk)}
        params.update({f"f{k}":str(v).zfill(2) for k,v in enumerate(fiplist)})
        params.update({"sy":start_year,"sq":start_qtr,"ey":end_year,"eq":end_qtr})
        sql=f"""
        SELECT id,fips,year,qtr
        FROM {table_name}
        WHERE id IN ({iph})
          AND fips IN ({fph})
          AND (year>:sy OR (year=:sy AND qtr>=:sq))
          AND (year<:ey OR (year=:ey AND qtr<=:eq))
        """
        with pool.acquire() as conn:
            cur=conn.cursor()
            cur.execute(sql,params)
            return cur.fetchall()
    chunks=[cohortlist[i:i+chunk_size] for i in range(0,len(cohortlist),chunk_size)]
    hits=[]
    with ThreadPoolExecutor(max_workers=workers) as ex:
        futs=[ex.submit(run_chunk,ch) for ch in chunks]
        for f in as_completed(futs): hits.extend(f.result())
    pool.close()
    seen=set((str(r[0]),str(r[1]).zfill(2),int(r[2]),int(r[3])) for r in hits)
    rows=[]
    for cid in cohortlist:
        scid=str(cid)
        for f in fiplist:
            sf=str(f).zfill(2)
            for y,q,lab in per:
                rows.append((scid,sf,lab,1 if (scid,sf,y,q) in seen else 0))
    presence=pd.DataFrame(rows,columns=["id","fips","yr_qtr","found"])
    agg_any=presence.groupby(["id","yr_qtr"],as_index=False)["found"].max().rename(columns={"found":"found_any"})
    per_index={lab:i for i,(_,_,lab) in enumerate(per)}
    agg_any["order"]=agg_any["yr_qtr"].map(per_index.get)
    agg_any=agg_any.sort_values(["id","order"])
    def longest_gap(z):
        m=0;c=0;s=None;best=(0,None,None)
        idx=list(z.index)
        for i,v in zip(idx,z.values):
            if v==0:
                c+=1
                if c==1: s=i
            else:
                if c>m: m=c; best=(m,s,s+c-1)
                c=0; s=None
        if c>m: m=c; best=(m,s,s+c-1)
        return best
    res_any=[]
    for k,df in agg_any.groupby("id"):
        mlen,s,e=longest_gap((1-df["found_any"]).astype(int))
        s_lab=per[s][2] if s is not None and mlen>0 else None
        e_lab=per[e][2] if e is not None and mlen>0 else None
        res_any.append((k,mlen,s_lab,e_lab))
    summary=pd.DataFrame(res_any,columns=["id","longest_not_found_len","start_yr_qtr","end_yr_qtr"])
    pres_state=presence.copy()
    pres_state["order"]=pres_state["yr_qtr"].map(per_index.get)
    pres_state=pres_state.sort_values(["id","fips","order"])
    res_state=[]
    for (cid,fips),df in pres_state.groupby(["id","fips"]):
        mlen,s,e=longest_gap((1-df["found"]).astype(int))
        s_lab=per[s][2] if s is not None and mlen>0 else None
        e_lab=per[e][2] if e is not None and mlen>0 else None
        res_state.append((cid,fips,mlen,s_lab,e_lab))
    per_state_summary=pd.DataFrame(res_state,columns=["id","fips","longest_not_found_len","start_yr_qtr","end_yr_qtr"])
    if save_presence_csv: presence.to_csv(save_presence_csv,index=False)
    if save_summary_csv: summary.to_csv(save_summary_csv,index=False)
    if save_per_state_csv: per_state_summary.to_csv(save_per_state_csv,index=False)
    if save_longest_plot or show_plots:
        df=summary.sort_values("longest_not_found_len",ascending=False)
        ids=df["id"].astype(str).values
        vals=df["longest_not_found_len"].values
        s=df["start_yr_qtr"].fillna("").values
        e=df["end_yr_qtr"].fillna("").values
        h=max(6,len(df)*0.22)
        plt.figure(figsize=(12,h))
        y=np.arange(len(df))
        plt.barh(y,vals)
        plt.yticks(y,ids)
        plt.xlabel("quarters")
        plt.title("Longest consecutive not-found by ID")
        plt.gca().invert_yaxis()
        for i,v in enumerate(vals):
            lbl=str(v) if v==0 or s[i]=="" else f"{v} ({s[i]}â†’{e[i]})"
            plt.text(v+0.05,i,lbl,va="center")
        plt.tight_layout()
        if save_longest_plot: plt.savefig(save_longest_plot,bbox_inches="tight",dpi=200)
        if show_plots: plt.show()
        plt.close()
    if save_distribution_plot or show_plots:
        vals=summary["longest_not_found_len"].values
        plt.figure(figsize=(8,5))
        plt.hist(vals,bins=range(0,(int(vals.max()) if len(vals)>0 else 0)+2),edgecolor="black",align="left")
        plt.xlabel("Longest not-found streak length (quarters)")
        plt.ylabel("Number of IDs")
        plt.title("Distribution of Longest Not-Found Streak Lengths")
        if len(vals)>0: plt.xticks(range(0,int(vals.max())+1))
        plt.tight_layout()
        if save_distribution_plot: plt.savefig(save_distribution_plot,bbox_inches="tight",dpi=200)
        if show_plots: plt.show()
        plt.close()
    return presence,summary,per_state_summary
