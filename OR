from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm
import logging



logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("fetch_bad")

def run_fetch_stat_bad(
    states: list[str],
    years: list[int],
    quarters: list[int],
    max_workers: int = 8,
    show_progress: bool = True,
) -> None:

    jobs = [(s, y, q) for s in states for y in years for q in quarters]

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        # submit all jobs
        future_to_job = {
            executor.submit(Fetch_STAT_BAD, state, year, quarter): (state, year, quarter)
            for state, year, quarter in jobs
        }

        # iterate as each completes
        if show_progress:
            iterator = tqdm(as_completed(future_to_job), total=len(future_to_job))
        else:
            iterator = as_completed(future_to_job)

        for fut in iterator:
            state, year, quarter = future_to_job[fut]
            try:
                fut.result()  # will re-raise if the job failed
                logger.info(f"✔ Done: {state} {year}-Q{quarter}")
            except Exception as e:
                logger.error(f"✘ Failed: {state} {year}-Q{quarter} → {e}")

if __name__ == "__main__":
    # example usage:
    STATES  = ["AL","AK","AZ","AR","CA", ... ]   # your full list
    YEARS   = list(range(2020, 2025))
    QUARTER = [1, 2, 3, 4]

    run_fetch_stat_bad(STATES, YEARS, QUARTER, max_workers=10)
