import itertools, os, math
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

def quarter_range(start_year, start_qtr, end_year, end_qtr):
    sy, sq, ey, eq = int(start_year), int(start_qtr), int(end_year), int(end_qtr)
    start_idx = (sy * 4) + (sq - 1)
    end_idx = (ey * 4) + (eq - 1)
    for idx in range(start_idx, end_idx + 1):
        y = idx // 4
        q = (idx % 4) + 1
        yield y, q

def Extract_QTR_safe(fips, year, quarter):
    try:
        df1, df_subset = Extract_QTR(fips, year, quarter)
        return {"ok": True, "fips": fips, "year": year, "qtr": quarter, "df1": df1, "subset": df_subset, "err": None}
    except Exception as e:
        return {"ok": False, "fips": fips, "year": year, "qtr": quarter, "df1": None, "subset": None, "err": repr(e)}

def run_multithread(start_year, start_qtr, end_year, end_qtr, max_workers=None):
    periods = list(quarter_range(start_year, start_qtr, end_year, end_qtr))
    jobs = [(f, y, q) for (y, q) in periods for f in fipslist]
    if max_workers is None:
        max_workers = max(4, min(32, (os.cpu_count() or 8) * 2))
    results = []
    with ThreadPoolExecutor(max_workers=max_workers) as ex:
        futs = [ex.submit(Extract_QTR_safe, f, y, q) for (f, y, q) in jobs]
        for fut in tqdm(as_completed(futs), total=len(futs)):
            results.append(fut.result())
    ok = [r for r in results if r["ok"]]
    errs = [r for r in results if not r["ok"]]
    if ok:
        all_df1 = pd.concat([r["df1"] for r in ok], ignore_index=True)
        all_subset = pd.concat([r["subset"] for r in ok], ignore_index=True)
    else:
        all_df1 = pd.DataFrame()
        all_subset = pd.DataFrame()
    if errs:
        err_df = pd.DataFrame([{"fips": r["fips"], "year": r["year"], "qtr": r["qtr"], "err": r["err"]} for r in errs])




import warnings; warnings.filterwarnings('ignore')
import streamlit as st
import os, time
import us
import polars as pl
import pandas as pd
import numpy as np
import pyarrow.dataset as ds
from concurrent.futures import ThreadPoolExecutor, as_completed
import oracledb

states = ['AL','AR','CT','FL','GA','IA','IL','IN','ID','KS','LA','MD','ME','MN','MT','NE','NJ','NM','OH','OK','OR','PA','RI','SC','SD','WA','WI','WV','WY','TX','UT']

def abbr2fips(abbr):
    state = us.states.lookup(abbr)
    return state.fips

full_fipslist = [abbr2fips(abbr) for abbr in states]

lookup = {'11':'11:Agriculture','21':'21:Mining','22':'22:Utilities','23':'23:Construction','31-33':'31-33:Manufacturing','42':'42:Wholesale Trade','44-45':'44-45:Retail Trade','48-49':'48-49:Transportation & Warehousing','51':'51:Information','52':'52:Finance & Insurance','53':'53:Real Estate, Rental & Leasing','54':'54:Profess, Science & Tech Srvs','55':'55:Management Srvs','56':'56:Admin Support Srvs','61':'61:Educational Srvs','62':'62:Healthcare & Social Assistance','71':'71:Arts, Entertainment and Rec','72':'72:Accommodations & Food Srvs','81':'81:Other Services','92':'92:Public Admin','99':'99:Unclassified'}

def lookup_naics2(naics2):
    return lookup.get(naics2,'00:Unknown')

def fips2name(state_code):
    try:
        return us.states.lookup(state_code.zfill(2)).name
    except AttributeError:
        return state_code

def dupeID(M):
    B = M.sort_values(by=['BLS_ID','WAGE'], ascending=[True,False])
    B = B.drop_duplicates(subset=['BLS_ID'],keep='first')
    return B

def Fetch_WR_QTR(query: str, params: dict, conn) -> pl.DataFrame:
    try:
        with conn.cursor() as cursor:
            cursor.execute(query, params)
            rows = cursor.fetchall()
            columns = [col[0] for col in cursor.description]
            df = pl.DataFrame(rows, schema=columns)
            df = df.with_columns(pl.col("STATE_CODE").cast(pl.Utf8))
            df = df.with_columns(pl.col('STATE_CODE').map_elements(lambda code: fips2name(code), return_dtype=pl.Utf8).alias('state'))
            df = df.with_columns((pl.col('YR').cast(pl.Utf8) + "-" + pl.col('QTR').cast(pl.Utf8)).alias('yr_qtr'))
            df = df.drop(["STATEUSE","HOURLYRATE","JOBTITLE","SOCCODE","WEEKS","HOURS","EIN","STATE_CODE"])
            return df.to_pandas()
    except oracledb.Error:
        return pl.DataFrame().to_pandas()

def Fetch_DOM_QTR(year,qtr,fips):
    dnaicsloc = "/wagerec/current_dominantnaics/parquet/"
    table = ds.dataset(dnaicsloc, format="parquet")
    DOM1 = pl.scan_pyarrow_dataset(table)
    f = fips.lstrip('0')
    DOM2 = DOM1.filter(pl.col('fips') == f).filter(pl.col('year') == year).filter(pl.col('qtr') == qtr)
    Final = DOM2.select(['ui_acct','fips','naics2','naics3','naics4','naics6','run']).collect().to_pandas()
    Final.rename(columns={'ui_acct':'UI','run':'RUN'}, inplace=True)
    return Final

def Extract_QTR(fips,year,quarter):
    query = "SELECT * FROM YQQ WHERE state_code = :fips AND YR = :year AND qtr = :quarter"
    params = {'fips':fips,'year':year,'quarter':quarter}
    user = os.getenv("ORACLE_USER") or open('USER.txt').read()
    pwd = os.getenv("ORACLE_PASSWORD") or open('password.txt').read()
    dsn = os.getenv("ORACLE_DSN","XQQQ")
    conn = oracledb.connect(user=user, password=pwd, dsn=dsn)
    WR = Fetch_WR_QTR(query, params, conn)
    conn.close()
    D = Fetch_DOM_QTR(year,quarter,fips)
    if 'UI' in D.columns:
        D['UI'] = D['UI'].astype(str).str.zfill(10)
    WR1 = WR[WR['WAGE'] != 0]
    WR2 = dupeID(WR1)
    df = pd.merge(WR2, D, how='left', on=['UI','RUN'], indicator=True)
    df1 = dupeID(df)
    df1['yr_qtr'] = df1['YR'].astype(str) + "-" + df1['QTR'].astype(str)
    df1['state'] = [fips2name(code) for code in df1['fips']]
    df1['sector'] = [lookup_naics2(str(code)) for code in df1['naics2']]
    df_subset = df1.groupby(['yr_qtr','state','sector']).agg(counts=('BLS_ID','count'), mean_wage=('WAGE','mean'), median_wage=('WAGE','median'), percentile75=('WAGE', lambda x: x.quantile(0.75)), percentile25=('WAGE', lambda x: x.quantile(0.25))).reset_index()
    return df1, df_subset

def quarter_range(start_year, start_qtr, end_year, end_qtr):
    sy, sq, ey, eq = int(start_year), int(start_qtr), int(end_year), int(end_qtr)
    start_idx = (sy*4)+(sq-1)
    end_idx = (ey*4)+(eq-1)
    for idx in range(start_idx, end_idx+1):
        y = idx//4
        q = (idx%4)+1
        yield y, q

def Extract_QTR_safe(fips, year, quarter):
    try:
        df1, df_subset = Extract_QTR(fips, year, quarter)
        return True, fips, year, quarter, df1, df_subset, None
    except Exception as e:
        return False, fips, year, quarter, None, None, repr(e)

def run_multithread(selected_fips, start_year, start_qtr, end_year, end_qtr, max_workers):
    periods = list(quarter_range(start_year, start_qtr, end_year, end_qtr))
    jobs = [(f, y, q) for (y, q) in periods for f in selected_fips]
    results = []
    progress = st.progress(0)
    total = len(jobs)
    done = 0
    with ThreadPoolExecutor(max_workers=max_workers) as ex:
        futures = [ex.submit(Extract_QTR_safe, f, y, q) for (f, y, q) in jobs]
        for fut in as_completed(futures):
            results.append(fut.result())
            done += 1
            progress.progress(int(done*100/total))
    ok = [r for r in results if r[0]]
    errs = [r for r in results if not r[0]]
    if ok:
        all_df1 = pd.concat([r[4] for r in ok], ignore_index=True)
        all_subset = pd.concat([r[5] for r in ok], ignore_index=True)
    else:
        all_df1 = pd.DataFrame()
        all_subset = pd.DataFrame()
    if errs:
        err_df = pd.DataFrame([{"fips": r[1], "year": r[2], "qtr": r[3], "err": r[6]} for r in errs])
    else:
        err_df = pd.DataFrame(columns=["fips","year","qtr","err"])
    return all_df1, all_subset, err_df

st.set_page_config(page_title="Quarterly Wage Extraction", layout="wide")
st.title("Quarterly Wage Extraction")
col1, col2, col3, col4 = st.columns(4)
with col1:
    start_year = st.number_input("Start Year", min_value=2000, max_value=2100, value=2022, step=1)
with col2:
    start_qtr = st.selectbox("Start Quarter", [1,2,3,4], index=0)
with col3:
    end_year = st.number_input("End Year", min_value=2000, max_value=2100, value=2023, step=1)
with col4:
    end_qtr = st.selectbox("End Quarter", [1,2,3,4], index=1)

sel_states = st.multiselect("States", states, default=states)
sel_fips = [abbr2fips(s) for s in sel_states]
max_workers = st.slider("Max Workers", min_value=2, max_value=64, value=12, step=2)

run = st.button("Run Extraction")

if run:
    t0 = time.time()
    all_df1, all_subset, err_df = run_multithread(sel_fips, start_year, start_qtr, end_year, end_qtr, max_workers)
    t1 = time.time()
    st.caption(f"Exec Time: {(t1-t0)/60:.2f} min")
    tab1, tab2, tab3 = st.tabs(["Detailed Results","Aggregated Summary","Errors"])
    with tab1:
        st.dataframe(all_df1, use_container_width=True)
        if not all_df1.empty:
            st.download_button("Download Detailed CSV", all_df1.to_csv(index=False).encode("utf-8"), file_name="detailed_results.csv", mime="text/csv")
    with tab2:
        st.dataframe(all_subset, use_container_width=True)
        if not all_subset.empty:
            st.download_button("Download Summary CSV", all_subset.to_csv(index=False).encode("utf-8"), file_name="summary_results.csv", mime="text/csv")
    with tab3:
        st.dataframe(err_df, use_container_width=True)
        if not err_df.empty:
            st.download_button("Download Errors CSV", err_df.to_csv(index=False).encode("utf-8"), file_name="errors.csv", mime="text/csv")
    else:
        err_df = pd.DataFrame(columns=["fips","year","qtr","err"])
    return all_df1, all_subset, err_df

start_year = 2022
start_qtr = 3
end_year = 2023
end_qtr = 2
all_df1, all_subset, err_df = run_multithread(start_year, start_qtr, end_year, end_qtr, max_workers=12)
