import polars as pl
import oracledb
from concurrent.futures import ThreadPoolExecutor, as_completed


# -----------------------------------------------------------
# 1. Fetch logic: runs one SQL query for one year/quarter
# -----------------------------------------------------------
def Fetch_WR_QTR(query: str, params: dict, conn) -> pl.DataFrame:
    try:
        with conn.cursor() as cursor:
            cursor.execute(query, params)
            rows = cursor.fetchall()
            columns = [col[0] for col in cursor.description]

            df = pl.DataFrame(rows, schema=columns)

            # Convert STATE_CODE to text
            df = df.with_columns(
                pl.col("STATE_CODE").cast(pl.Utf8)
            )

            # Map FIPS -> full state name
            df = df.with_columns(
                pl.col("STATE_CODE")
                .map_elements(lambda code: fips2name(code), return_dtype=pl.Utf8)
                .alias("state")
            )

            # Build yr_qtr string like "2021.3"
            df = df.with_columns(
                (pl.col("YEAR").cast(pl.Utf8) + "." +
                 pl.col("QTR").cast(pl.Utf8)).alias("yr_qtr")
            )

            # Return only required output columns
            return df.select([
                "yr_qtr",
                "state",
                "zero_wage_count",
                "million_wage_count"
            ])

    except oracledb.Error as e:
        print("WTF?:", e)
        return pl.DataFrame()


# -----------------------------------------------------------
# 2. Worker that runs one quarter in one thread
# -----------------------------------------------------------
def process_one_period(year, qtr, conn_string):
    conn = oracledb.connect(conn_string)

    query = """
        SELECT
            t.STATE_CODE,
            t.YEAR,
            t.QTR,
            COUNT(CASE WHEN t.WAGE = 0 THEN 1 END) AS zero_wage_count,
            COUNT(CASE WHEN t.WAGE > 1000000 THEN 1 END) AS million_wage_count
        FROM WAGE_RECORDS t
        WHERE t.YEAR = :year
          AND t.QTR  = :qtr
        GROUP BY
            t.STATE_CODE,
            t.YEAR,
            t.QTR
        ORDER BY
            t.STATE_CODE,
            t.YEAR,
            t.QTR
    """

    df = Fetch_WR_QTR(query, {"year": year, "qtr": qtr}, conn)
    conn.close()
    return df


# -----------------------------------------------------------
# 3. Full multithread driver - 2020Q1 to 2025Q1
# -----------------------------------------------------------
def get_all_zero_and_million_counts(conn_string, max_workers=24):

    # year-quarter list
    quarters = [(y, q) for y in range(2020, 2026) for q in range(1, 5)]
    # stop at 2025 Q1
    quarters = [(y, q) for (y, q) in quarters if not (y == 2025 and q > 1)]

    tasks = []
    results = []

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        for year, qtr in quarters:
            tasks.append(
                executor.submit(process_one_period, year, qtr, conn_string)
            )

        for task in as_completed(tasks):
            results.append(task.result())

    return pl.concat(results, how="vertical")



# -----------------------------------------------------------
# Example use:
# df = get_all_zero_and_million_counts("user/pw@host:1521/service", max_workers=24)
# print(df)
# -----------------------------------------------------------
